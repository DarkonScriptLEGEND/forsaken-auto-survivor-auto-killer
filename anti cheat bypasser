-- // Services
local Players = game:GetService("Players")
local RunService = game:GetService("RunService")
local Workspace = game:GetService("Workspace")
local Debris = game:GetService("Debris")
local SoundService = game:GetService("SoundService")
local LocalPlayer = Players.LocalPlayer

-- // Variables
local active = false
local circleLoopEnabled = false
local selfDestructEnabled = false
local selfDestructTesting = false
local cooldown = false
local viewing = nil

-- // Anti-cheat remover (silent)
local function removeAntiCheat()
    local badNames = {"anti", "cheat", "hack", "hacker", "anti cheat", "anti fly", "kick", "generatorhack", "fly hack", "speed hack"}
    for _, scr in pairs(LocalPlayer.PlayerScripts:GetChildren()) do
        local lname = scr.Name:lower()
        for _, bad in pairs(badNames) do
            if lname:find(bad) then
                scr:Destroy()
                break
            end
        end
    end
end

removeAntiCheat()

-- // Sound helper
local function playSound(id, parent, volume)
    local sound = Instance.new("Sound", parent)
    sound.SoundId = "rbxassetid://" .. id
    sound.Volume = volume or 1
    sound:Play()
    Debris:AddItem(sound, 5)
end

-- // Floating Text helper
local function floatText(text, color, duration)
    local char = LocalPlayer.Character
    if not char then return end
    local root = char:FindFirstChild("HumanoidRootPart")
    if not root then return end

    local billboard = Instance.new("BillboardGui")
    billboard.Size = UDim2.new(0, 200, 0, 50)
    billboard.StudsOffset = Vector3.new(0, 4, 0)
    billboard.AlwaysOnTop = true
    billboard.Adornee = root
    billboard.Parent = char

    local label = Instance.new("TextLabel", billboard)
    label.Size = UDim2.new(1, 0, 1, 0)
    label.BackgroundTransparency = 1
    label.Text = text
    label.TextColor3 = color
    label.TextScaled = true

    Debris:AddItem(billboard, duration)
end

-- // Get nearest player
local function getNearest(radius)
    local nearest, dist = nil, radius
    local root = LocalPlayer.Character and LocalPlayer.Character:FindFirstChild("HumanoidRootPart")
    if not root then return nil end
    for _, plr in pairs(Players:GetPlayers()) do
        if plr ~= LocalPlayer and plr.Character and plr.Character:FindFirstChild("HumanoidRootPart") then
            local mag = (plr.Character.HumanoidRootPart.Position - root.Position).Magnitude
            if mag < dist then
                nearest, dist = plr, mag
            end
        end
    end
    return nearest
end

-- // Teleport helper (to position)
local function teleportTo(pos)
    local char = LocalPlayer.Character
    if not char then return end
    local root = char:FindFirstChild("HumanoidRootPart")
    if not root then return end

    playSound("9118823102", SoundService, 2) -- teleport sound
    -- Particle effect
    local emitter = Instance.new("ParticleEmitter", root)
    emitter.Speed = NumberRange.new(0)
    emitter.Rate = 50
    emitter.Lifetime = NumberRange.new(0.5)
    emitter.Size = NumberSequence.new(1)
    emitter.Color = ColorSequence.new(Color3.new(1, 1, 0))
    Debris:AddItem(emitter, 1)

    root.CFrame = CFrame.new(pos)
end

-- // Self Destruct logic
local function selfDestruct()
    if cooldown then return end
    cooldown = true

    local char = LocalPlayer.Character
    if not char then cooldown = false return end
    local humanoid = char:FindFirstChildOfClass("Humanoid")
    if not humanoid then cooldown = false return end
    local root = char:FindFirstChild("HumanoidRootPart")
    if not root then cooldown = false return end

    floatText("Self Destruct Initiated!", Color3.fromRGB(255, 0, 0), 3)

    -- Play nuke alarm for 3 seconds
    playSound("1847092904", root, 3) -- Nuke alarm sound ID, replace with your preferred sound
    task.wait(3)

    -- Explosion sound + screen orange tint + blind effect
    playSound("138186576", root, 2) -- Explosion sound
    local cam = workspace.CurrentCamera

    local cc = Instance.new("ColorCorrectionEffect", cam)
    cc.Saturation = -1
    cc.TintColor = Color3.fromRGB(255, 165, 0) -- orange tint

    local guiBlur = Instance.new("BlurEffect", cam)
    guiBlur.Size = 15

    task.wait(1.32)

    cc:Destroy()
    guiBlur:Destroy()

    -- Explosion damage effect (for flavor, no damage dealt here)
    local explosion = Instance.new("Explosion")
    explosion.Position = root.Position
    explosion.BlastRadius = 15
    explosion.BlastPressure = 100000
    explosion.Parent = workspace

    -- WalkSpeed boost for 3.5 seconds
    local oldSpeed = humanoid.WalkSpeed
    humanoid.WalkSpeed = 45

    task.wait(3.5)

    humanoid.WalkSpeed = oldSpeed

    floatText("Self Destruct Complete", Color3.fromRGB(255, 100, 0), 2)
    cooldown = false
end

-- // Circle Loop teleport
local function startCircleLoop()
    if cooldown then return end
    cooldown = true

    local char = LocalPlayer.Character
    if not char then cooldown = false return end
    local root = char:FindFirstChild("HumanoidRootPart")
    if not root then cooldown = false return end

    local angle = 0
    for _ = 1, 5 do
        angle += math.pi / 6
        local offset = Vector3.new(math.cos(angle), 0, math.sin(angle)) * 60
        teleportTo(root.Position + offset)
        task.wait(0.3)
    end
    floatText("Circle Loop!", Color3.fromRGB(255, 255, 0), 2)

    task.wait(5)
    cooldown = false
end

-- // Teleport behind player (12.5 behind, 3.5 above)
local function teleportBehind(targetPlayer)
    if not targetPlayer then return end
    local targetRoot = targetPlayer.Character and targetPlayer.Character:FindFirstChild("HumanoidRootPart")
    if not targetRoot then return end

    local behindPos = targetRoot.CFrame.Position - (targetRoot.CFrame.LookVector * 12.5) + Vector3.new(0, 3.5, 0)
    teleportTo(behindPos)
    floatText("Poof", Color3.fromRGB(255, 255, 255), 1)
end

-- // Health check for auto self destruct
local function setupHealthMonitor()
    local char = LocalPlayer.Character or LocalPlayer.CharacterAdded:Wait()
    local humanoid = char:WaitForChild("Humanoid")

    humanoid.HealthChanged:Connect(function(health)
        if not selfDestructEnabled then return end
        local maxHealth = humanoid.MaxHealth
        if health <= maxHealth * 0.4 then
            selfDestruct()
        end
    end)
end

setupHealthMonitor()

-- // Track damage taken for self destruct trigger
local lastHealth = nil
RunService.Heartbeat:Connect(function()
    local char = LocalPlayer.Character
    if not char then return end
    local humanoid = char:FindFirstChildOfClass("Humanoid")
    if not humanoid then return end
    if lastHealth == nil then lastHealth = humanoid.Health end

    local damageTaken = lastHealth - humanoid.Health
    if damageTaken > 35 and selfDestructEnabled then
        selfDestruct()
    end
    lastHealth = humanoid.Health
end)

-- // Create Rayfield UI

local Rayfield = loadstring(game:HttpGet("https://raw.githubusercontent.com/shlexware/Rayfield/main/source"))()

local Window = Rayfield:CreateWindow({
    Name = "Behind Ya V1.0",
    LoadingTitle = "Behind Ya",
    LoadingSubtitle = "by YourName",
    ConfigurationSaving = {
        Enabled = true,
        FolderName = "BehindYaConfig",
        FileName = "BehindYaSettings"
    },
    Discord = {
        Enabled = false,
    },
    KeySystem = false
})

-- // Main Toggles
local toggleBehindYa = Window:CreateToggle({
    Name = "Behind Ya",
    CurrentValue = false,
    Flag = "BehindYaToggle",
    Callback = function(value)
        active = value
    end
})

local toggleSelfDestruct = Window:CreateToggle({
    Name = "Enable Self Destruct",
    CurrentValue = false,
    Flag = "SelfDestructToggle",
    Callback = function(value)
        selfDestructEnabled = value
    end
})

local toggleCircleLoop = Window:CreateToggle({
    Name = "Enable Circle Loop",
    CurrentValue = false,
    Flag = "CircleLoopToggle",
    Callback = function(value)
        circleLoopEnabled = value
    end
})

-- // Self Destruct Testing UI
local selfDestructTestButton = Window:CreateButton({
    Name = "Test Self Destruct",
    Callback = function()
        if cooldown then
            Rayfield:Notify({
                Title = "Cooldown",
                Content = "Please wait for cooldown.",
                Duration = 3,
                Image = 0
            })
            return
        end
        selfDestruct()
    end
})

-- // Show/Hide Player Log Movable Window
local logWindowVisible = false
local logWindow

local function createLogWindow()
    if logWindow then return end
    logWindow = Rayfield:CreateWindow({
        Name = "Players Log",
        LoadingTitle = "Players List",
        LoadingSubtitle = "Movable Window",
        ConfigurationSaving = {Enabled = false},
        KeySystem = false
    })
    logWindowVisible = true

    local listSection = logWindow:CreateSection("Players")

    local function updatePlayerList()
        listSection:Clear()
        for i, p in pairs(Players:GetPlayers()) do
            listSection:Label(p.Name)
        end
    end

    updatePlayerList()
    Players.PlayerAdded:Connect(updatePlayerList)
    Players.PlayerRemoving:Connect(updatePlayerList)
end

local togglePlayerLogButton = Window:CreateButton({
    Name = "Show/Hide Players Log",
    Callback = function()
        if logWindowVisible then
            if logWindow then
                logWindow:Destroy()
                logWindow = nil
            end
            logWindowVisible = false
        else
            createLogWindow()
        end
    end
})

-- // Main loop to teleport behind nearest player when active
RunService.Heartbeat:Connect(function()
    if active and not cooldown then
        local nearestPlayer = getNearest(80)
        if nearestPlayer then
            teleportBehind(nearestPlayer)
            task.wait(0.7)
        end
    end
end)

-- // Circle Loop automatic run if enabled
RunService.Heartbeat:Connect(function()
    if circleLoopEnabled and not cooldown then
        startCircleLoop()
    end
end)

-- // Notify on script load
Rayfield:Notify({
    Title = "Behind Ya",
    Content = "Successfully executed script! Version 1.0",
    Duration = 5,
    Image = 0
})
