--// SERVICES
local Players = game:GetService("Players")
local PathfindingService = game:GetService("PathfindingService")
local RunService = game:GetService("RunService")
local ReplicatedStorage = game:GetService("ReplicatedStorage")
local LocalPlayer = Players.LocalPlayer

--// VARIABLES
local Character = LocalPlayer.Character or LocalPlayer.CharacterAdded:Wait()
local Humanoid = Character:WaitForChild("Humanoid")
local RootPart = Character:WaitForChild("HumanoidRootPart")
local Stamina = Humanoid:FindFirstChild("Stamina") or Instance.new("NumberValue", Humanoid) -- replace if different

local autoSurvivor = false
local autoKiller = false

--// GUI
local gui = Instance.new("ScreenGui", game.CoreGui)
gui.Name = "ForsakenAI"

local function createButton(name, posY)
	local btn = Instance.new("TextButton", gui)
	btn.Size = UDim2.new(0, 180, 0, 35)
	btn.Position = UDim2.new(0, 10, 0, posY)
	btn.BackgroundColor3 = Color3.fromRGB(60, 60, 60)
	btn.TextColor3 = Color3.fromRGB(255, 255, 255)
	btn.Text = name
	return btn
end

local autoSurvivorBtn = createButton("Auto Survivor: OFF", 10)
local autoKillerBtn = createButton("Auto Killer: OFF", 50)

--// UTILS

local function inMatch()
	-- Customize per your game logic
	return workspace:FindFirstChild("Match") ~= nil
end

local function isKiller()
	local team = LocalPlayer.Team
	return team and team.Name == "Killer"
end

local function isSurvivor()
	local team = LocalPlayer.Team
	return team and team.Name == "Survivor"
end

local function findNearestPlayer(teamName)
	local nearest = nil
	local nearestDist = math.huge
	for _, player in pairs(Players:GetPlayers()) do
		if player ~= LocalPlayer and player.Team and player.Team.Name == teamName and player.Character and player.Character:FindFirstChild("HumanoidRootPart") then
			local dist = (player.Character.HumanoidRootPart.Position - RootPart.Position).Magnitude
			if dist < nearestDist then
				nearestDist = dist
				nearest = player.Character.HumanoidRootPart
			end
		end
	end
	return nearest, nearestDist
end

local function pathfindTo(pos)
	local path = PathfindingService:CreatePath({
		AgentRadius = 2,
		AgentHeight = 5,
		AgentCanJump = true,
		AgentCanClimb = true,
	})
	path:ComputeAsync(RootPart.Position, pos)
	if path.Status == Enum.PathStatus.Complete then
		for _, waypoint in ipairs(path:GetWaypoints()) do
			Humanoid:MoveTo(waypoint.Position)
			local reached = Humanoid.MoveToFinished:Wait()
			if not reached then break end
		end
	end
end

local function sprint(enable)
	if enable then
		Humanoid.WalkSpeed = 22
	else
		Humanoid.WalkSpeed = 16
	end
end

--// AI FUNCTIONS

local function dodgeAbility(killerHRP)
	-- Detect killer ability usage (pseudo detection)
	-- This is a simplified example, replace with actual detection:
	local dist = (killerHRP.Position - RootPart.Position).Magnitude
	if dist < 15 then
		-- Dodge by moving sideways randomly
		local dodgeDir = Vector3.new(math.random(-1,1), 0, math.random(-1,1)).Unit * 20
		local dodgePos = RootPart.Position + dodgeDir
		pathfindTo(dodgePos)
		task.wait(0.3)
		return true
	end
	return false
end

local function autoRepairGenerators()
	for _, gen in pairs(workspace:GetChildren()) do
		if gen.Name == "Generator" and gen:FindFirstChild("Health") and gen.Health.Value < gen.Health.MaxValue then
			-- Move to generator and repair
			pathfindTo(gen.Position)
			if gen:FindFirstChild("Repair") then
				gen.Repair:FireServer()
			end
			task.wait(1)
		end
	end
end

local function survivorAI()
	while autoSurvivor and inMatch() and isSurvivor() and Humanoid.Health > 0 do
		local killerHRP, dist = findNearestPlayer("Killer")
		if killerHRP then
			if dist < 40 then
				if not dodgeAbility(killerHRP) then
					-- Run away from killer intelligently
					local runDir = (RootPart.Position - killerHRP.Position).Unit * 30
					local runPos = RootPart.Position + runDir
					pathfindTo(runPos)
				end
				sprint(true)
			else
				sprint(false)
				autoRepairGenerators()
			end
		else
			sprint(false)
			autoRepairGenerators()
		end
		task.wait(0.3)
	end
	sprint(false)
end

local abilityCooldown = false
local function useKillerAbility()
	if abilityCooldown then return end
	abilityCooldown = true
	-- Fire the killer's ability remote event (customize)
	local abilityEvent = ReplicatedStorage:FindFirstChild("UseAbility")
	if abilityEvent then
		abilityEvent:FireServer()
	end
	task.wait(5) -- Cooldown time
	abilityCooldown = false
end

local function killerAI()
	while autoKiller and inMatch() and isKiller() and Humanoid.Health > 0 do
		local survivorHRP, dist = findNearestPlayer("Survivor")
		if survivorHRP then
			-- Chase survivor
			pathfindTo(survivorHRP.Position)
			if dist < 10 then
				useKillerAbility()
			end
		end
		task.wait(0.5)
	end
end

--// GUI BUTTONS

autoSurvivorBtn.MouseButton1Click:Connect(function()
	if inMatch() and isSurvivor() then
		autoSurvivor = not autoSurvivor
		autoSurvivorBtn.Text = "Auto Survivor: " .. (autoSurvivor and "ON" or "OFF")
		if autoSurvivor then
			task.spawn(survivorAI)
		end
	else
		autoSurvivorBtn.Text = "Not in match or not survivor"
		task.wait(2)
		autoSurvivorBtn.Text = "Auto Survivor: OFF"
	end
end)

autoKillerBtn.MouseButton1Click:Connect(function()
	if inMatch() and isKiller() then
		autoKiller = not autoKiller
		autoKillerBtn.Text = "Auto Killer: " .. (autoKiller and "ON" or "OFF")
		if autoKiller then
			task.spawn(killerAI)
		end
	else
		autoKillerBtn.Text = "Not in match or not killer"
		task.wait(2)
		autoKillerBtn.Text = "Auto Killer: OFF"
	end
end)
