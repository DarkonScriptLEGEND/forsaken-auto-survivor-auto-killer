--// Services
local Players = game:GetService("Players")
local RunService = game:GetService("RunService")
local PathfindingService = game:GetService("PathfindingService")
local Workspace = game:GetService("Workspace")
local StarterGui = game:GetService("StarterGui")

local LocalPlayer = Players.LocalPlayer

--// Variables
local autoSurvivorEnabled = false
local autoKillerEnabled = false
local humanoid = nil
local character = nil
local killer = nil
local stamina = 100
local maxStamina = 100
local staminaRegenRate = 10 -- per second
local sprintCost = 20 -- stamina cost per second sprinting

--// Anti Cheat Bypass
local function removeSuspiciousScripts()
    for _, scr in pairs(LocalPlayer.PlayerScripts:GetChildren()) do
        if scr:IsA("Script") or scr:IsA("LocalScript") then
            local nameLower = scr.Name:lower()
            if string.find(nameLower, "cheat") or string.find(nameLower, "anti") then
                scr:Destroy()
            end
        end
    end
end

removeSuspiciousScripts()

--// Utility Functions
local function notify(msg, duration, color)
    StarterGui:SetCore("SendNotification", {
        Title = "Auto Mode",
        Text = msg,
        Duration = duration or 3,
        Icon = "",
        Button1 = "OK"
    })
end

local function isInMatch()
    -- Match detection: Adapt this to the game's actual way to detect match
    -- For Forsaken, check if some "MatchState" value exists and active
    local matchState = Workspace:FindFirstChild("MatchState")
    if matchState and matchState.Value == "InGame" then
        return true
    end
    -- Sometimes check for a "Round" or other indicators, add here as needed
    return false
end

local function getCharacter()
    character = LocalPlayer.Character or LocalPlayer.CharacterAdded:Wait()
    humanoid = character:WaitForChild("Humanoid")
    return character, humanoid
end

local function findKiller()
    -- Find the player who is killer
    for _, plr in pairs(Players:GetPlayers()) do
        if plr ~= LocalPlayer then
            local plrChar = plr.Character
            if plrChar and plrChar:FindFirstChild("Humanoid") and plr.Character:FindFirstChild("IsKiller") then
                -- This assumes there is an "IsKiller" BoolValue or similar; adjust to game specifics
                if plrChar.IsKiller.Value == true then
                    return plr
                end
            end
        end
    end
    return nil
end

local function getGeneratorPositions()
    -- This function scans workspace for generators (adjust as per game)
    local gens = {}
    for _, obj in pairs(Workspace:GetDescendants()) do
        if obj.Name:lower():find("generator") and obj:IsA("BasePart") then
            table.insert(gens, obj.Position)
        end
    end
    return gens
end

local function findNearestGenerator()
    local charPos = character.HumanoidRootPart.Position
    local gens = getGeneratorPositions()
    local nearest = nil
    local shortestDist = math.huge
    for _, genPos in pairs(gens) do
        local dist = (genPos - charPos).Magnitude
        if dist < shortestDist then
            shortestDist = dist
            nearest = genPos
        end
    end
    return nearest
end

local function pathTo(position)
    if not humanoid or humanoid.Health <= 0 then return end
    local root = character:FindFirstChild("HumanoidRootPart")
    if not root then return end

    local path = PathfindingService:CreatePath()
    path:ComputeAsync(root.Position, position)
    if path.Status == Enum.PathStatus.Success then
        local waypoints = path:GetWaypoints()
        for _, waypoint in pairs(waypoints) do
            if humanoid.Health <= 0 then break end
            humanoid:MoveTo(waypoint.Position)
            local reached = humanoid.MoveToFinished:Wait()
            if not reached then break end
        end
    else
        -- fallback: simple direct move
        humanoid:MoveTo(position)
    end
end

--// AI Logic

-- Sprint control for survivor
local sprinting = false
local sprintStartTime = 0

local function startSprint()
    if stamina > 10 and not sprinting then
        sprinting = true
        humanoid.WalkSpeed = 22 -- sprint speed, adjust if needed
        sprintStartTime = tick()
    end
end

local function stopSprint()
    if sprinting then
        sprinting = false
        humanoid.WalkSpeed = 16 -- normal walk speed
    end
end

local function updateStamina(dt)
    if sprinting then
        stamina = math.max(stamina - sprintCost * dt, 0)
        if stamina <= 0 then
            stopSprint()
        end
    else
        stamina = math.min(stamina + staminaRegenRate * dt, maxStamina)
    end
end

-- Survivor AI: Noob behavior
local function survivorNoobBehavior()
    if not killer then return end
    local root = character:FindFirstChild("HumanoidRootPart")
    local killerChar = killer.Character
    if not root or not killerChar then return end
    local killerRoot = killerChar:FindFirstChild("HumanoidRootPart")
    if not killerRoot then return end

    local distToKiller = (root.Position - killerRoot.Position).Magnitude
    -- Run away if killer is within 40 studs
    if distToKiller < 40 then
        startSprint()
        -- Run directly away from killer (simple)
        local direction = (root.Position - killerRoot.Position).Unit
        local runToPos = root.Position + direction * 40
        pathTo(runToPos)
    else
        stopSprint()
        -- If safe, go to nearest generator
        local genPos = findNearestGenerator()
        if genPos then
            pathTo(genPos)
        end
    end
end

-- Survivor AI: Shedletsky behavior (more cautious, uses ability)
local function survivorShedletskyBehavior()
    if not killer then return end
    local root = character:FindFirstChild("HumanoidRootPart")
    local killerChar = killer.Character
    if not root or not killerChar then return end
    local killerRoot = killerChar:FindFirstChild("HumanoidRootPart")
    if not killerRoot then return end

    local distToKiller = (root.Position - killerRoot.Position).Magnitude
    if distToKiller < 50 then
        startSprint()
        -- Circle around killer to dodge
        local offset = Vector3.new(math.cos(tick()*5),0,math.sin(tick()*5)) * 15
        local runToPos = killerRoot.Position + offset
        pathTo(runToPos)
    else
        stopSprint()
        local genPos = findNearestGenerator()
        if genPos then
            pathTo(genPos)
        end
    end
    -- Ability usage (stub, adjust for game ability system)
    -- Example: if ability ready and killer close, use it here
end

local function runAutoSurvivor()
    if not autoSurvivorEnabled then return end
    if humanoid.Health <= 0 then return end
    if not isInMatch() then
        notify("Not in a match - Auto Survivor disabled", 3, Color3.new(1,0,0))
        autoSurvivorEnabled = false
        return
    end

    killer = findKiller()
    if not killer then return end

    -- Example survivor role selection: toggle between noob and shedletsky randomly for demo
    -- You can expand this with role detection or user selection
    local role = "Noob" -- or "Shedletsky"
    -- For demonstration: random role switch every 30 seconds
    if tick() % 60 < 30 then
        role = "Noob"
    else
        role = "Shedletsky"
    end

    if role == "Noob" then
        survivorNoobBehavior()
    else
        survivorShedletskyBehavior()
    end
end

-- Killer AI: Basic chasing and ability use
local function runAutoKiller()
    if not autoKillerEnabled then return end
    if humanoid.Health <= 0 then return end
    if not isInMatch() then
        notify("Not in a match - Auto Killer disabled", 3, Color3.new(1,0,0))
        autoKillerEnabled = false
        return
    end

    -- Killer should chase nearest survivor
    local nearestSurvivor = nil
    local nearestDist = math.huge
    local root = character:FindFirstChild("HumanoidRootPart")
    if not root then return end

    for _, plr in pairs(Players:GetPlayers()) do
        if plr ~= LocalPlayer and plr.Team ~= LocalPlayer.Team then
            local plrChar = plr.Character
            if plrChar and plrChar:FindFirstChild("Humanoid
