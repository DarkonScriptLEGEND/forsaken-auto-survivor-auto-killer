--// Services
local Players = game:GetService("Players")
local RunService = game:GetService("RunService")
local ReplicatedStorage = game:GetService("ReplicatedStorage")
local Workspace = game:GetService("Workspace")
local Teams = game:GetService("Teams")
local PathfindingService = game:GetService("PathfindingService")
local StarterGui = game:GetService("StarterGui")

local LocalPlayer = Players.LocalPlayer
local Character = nil
local Humanoid = nil
local HumanoidRootPart = nil

--// Variables
local autoSurvivorEnabled = false
local autoKillerEnabled = false
local antiCheatRemoved = false

--// Utility Functions
local function inMatch()
    -- Check workspace RoundActive BoolValue
    local roundActive = Workspace:FindFirstChild("RoundActive")
    if roundActive and roundActive:IsA("BoolValue") and roundActive.Value then
        return true
    end

    -- Check workspace GameState/RoundActive BoolValue
    local gameState = Workspace:FindFirstChild("GameState")
    if gameState then
        local roundBool = gameState:FindFirstChild("RoundActive")
        if roundBool and roundBool:IsA("BoolValue") and roundBool.Value then
            return true
        end
    end

    -- Check ReplicatedStorage MatchState IntValue > 0
    local repMatchState = ReplicatedStorage:FindFirstChild("MatchState")
    if repMatchState and repMatchState:IsA("IntValue") and repMatchState.Value > 0 then
        return true
    end

    -- Fallback: Check Teams for killer & survivor presence
    local killers = 0
    local survivors = 0
    for _, player in pairs(Players:GetPlayers()) do
        if player.Team then
            local teamName = player.Team.Name:lower()
            if teamName:find("killer") then
                killers = killers + 1
            elseif teamName:find("survivor") then
                survivors = survivors + 1
            end
        end
    end
    if killers > 0 and survivors > 0 then
        return true
    end

    return false
end

local function getCharacter()
    Character = LocalPlayer.Character or LocalPlayer.CharacterAdded:Wait()
    Humanoid = Character:FindFirstChildOfClass("Humanoid")
    HumanoidRootPart = Character:WaitForChild("HumanoidRootPart")
end

local function isKiller()
    if LocalPlayer.Team and LocalPlayer.Team.Name:lower():find("killer") then
        return true
    end
    return false
end

local function removeAntiCheatScripts()
    if antiCheatRemoved then return end
    for _, scr in pairs(getloadedmodules and getloadedmodules() or {}) do
        local name = scr.Name:lower()
        if name:find("cheat") or name:find("anti") or name:find("cheater") then
            pcall(function() package.loaded[scr] = nil end)
        end
    end
    for _, scr in pairs(Workspace:GetChildren()) do
        if scr:IsA("Script") or scr:IsA("LocalScript") then
            local name = scr.Name:lower()
            if name:find("cheat") or name:find("anti") or name:find("cheater") then
                pcall(function() scr:Destroy() end)
            end
        end
    end
    antiCheatRemoved = true
end

local function runAwayFromKiller(killerPos)
    -- Pathfind to a point away from killer, randomize direction a bit
    if not HumanoidRootPart then return end
    local direction = (HumanoidRootPart.Position - killerPos).Unit
    local fleeDistance = 40 + math.random(5, 15)
    local targetPos = HumanoidRootPart.Position + direction * fleeDistance

    -- Ensure targetPos is on the map (try to get ground position)
    local ray = Ray.new(targetPos + Vector3.new(0, 50, 0), Vector3.new(0, -100, 0))
    local hit, pos = Workspace:FindPartOnRay(ray)
    if hit then targetPos = Vector3.new(targetPos.X, pos.Y + 3, targetPos.Z) end

    -- Pathfinding
    local path = PathfindingService:CreatePath()
    path:ComputeAsync(HumanoidRootPart.Position, targetPos)
    if path.Status == Enum.PathStatus.Success then
        local waypoints = path:GetWaypoints()
        for _, waypoint in ipairs(waypoints) do
            Humanoid:MoveTo(waypoint.Position)
            local reached = Humanoid.MoveToFinished:Wait()
            if not reached then break end
        end
    else
        -- If path fails just move directly
        Humanoid:MoveTo(targetPos)
    end
end

local function dodgeAbility()
    -- Example dodge behavior, random sidestep or jump when killer ability detected
    -- This part requires you to detect killer ability usage in your game, so customize accordingly
    -- For demonstration, just do a random jump or sidestep every few seconds
    if not Humanoid or not HumanoidRootPart then return end
    if math.random() < 0.5 then
        Humanoid.Jump = true
    else
        local sidestepDir = Vector3.new(math.random(-1,1), 0, math.random(-1,1)).Unit * 5
        Humanoid:MoveTo(HumanoidRootPart.Position + sidestepDir)
    end
end

local function useAbility()
    -- Placeholder for using survivor or killer abilities
    -- Customize depending on the game and survivor/killer roles
    -- Example: call RemoteEvent to use ability
end

local function regainStamina()
    -- When stamina is low, stop moving for a bit
    -- Example: wait while stamina below threshold
end

local function autoGenerator()
    -- Auto activate generators for survivors
    -- This depends on your game's generator parts and remote events
end

--// GUI Setup
local ScreenGui = Instance.new("ScreenGui")
ScreenGui.Name = "AutoPlayGUI"
ScreenGui.Parent = game.CoreGui

local frame = Instance.new("Frame", ScreenGui)
frame.Size = UDim2.new(0, 220, 0, 130)
frame.Position = UDim2.new(0, 10, 0, 10)
frame.BackgroundColor3 = Color3.fromRGB(30,30,30)
frame.BorderSizePixel = 0
frame.Active = true
frame.Draggable = true

local title = Instance.new("TextLabel", frame)
title.Size = UDim2.new(1, 0, 0, 25)
title.BackgroundTransparency = 1
title.Text = "Forsaken Auto Play"
title.TextColor3 = Color3.fromRGB(255, 170, 0)
title.Font = Enum.Font.GothamBold
title.TextSize = 18

local autoSurvivorBtn = Instance.new("TextButton", frame)
autoSurvivorBtn.Position = UDim2.new(0, 10, 0, 40)
autoSurvivorBtn.Size = UDim2.new(1, -20, 0, 30)
autoSurvivorBtn.BackgroundColor3 = Color3.fromRGB(45, 45, 45)
autoSurvivorBtn.TextColor3 = Color3.fromRGB(255, 255, 255)
autoSurvivorBtn.Font = Enum.Font.GothamSemibold
autoSurvivorBtn.TextSize = 16
autoSurvivorBtn.Text = "Auto Survivor: OFF"

local autoKillerBtn = Instance.new("TextButton", frame)
autoKillerBtn.Position = UDim2.new(0, 10, 0, 80)
autoKillerBtn.Size = UDim2.new(1, -20, 0, 30)
autoKillerBtn.BackgroundColor3 = Color3.fromRGB(45, 45, 45)
autoKillerBtn.TextColor3 = Color3.fromRGB(255, 255, 255)
autoKillerBtn.Font = Enum.Font.GothamSemibold
autoKillerBtn.TextSize = 16
autoKillerBtn.Text = "Auto Killer: OFF"

--// Feedback Message
local function notify(text, color)
    StarterGui:SetCore("SendNotification", {
        Title = "Forsaken Auto Play";
        Text = text;
        Duration = 3;
        Button1 = "OK";
        Icon = "";
    })
end

--// Toggle functions
autoSurvivorBtn.MouseButton1Click:Connect(function()
    if not inMatch() then
        notify("Not in a match!")
        return
    end
    autoSurvivorEnabled = not autoSurvivorEnabled
    if autoSurvivorEnabled then
        autoSurvivorBtn.Text = "Auto Survivor: ON"
        notify("Auto Survivor Activated")
    else
        autoSurvivorBtn.Text = "Auto Survivor: OFF"
        notify("Auto Survivor Deactivated")
    end
end)

autoKillerBtn.MouseButton1Click:Connect(function()
    if not inMatch() then
        notify("Not in a match!")
        return
    end
    if not isKiller() then
        notify("You are not killer!")
        return
    end
    autoKillerEnabled = not autoKillerEnabled
    if autoKillerEnabled then
        autoKillerBtn.Text = "Auto Killer: ON"
        notify("Auto Killer Activated")
    else
        autoKillerBtn.Text = "Auto Killer: OFF"
        notify("Auto Killer Deactivated")
    end
end)

--// Main loop
getCharacter()
removeAntiCheatScripts()

RunService.Heartbeat:Connect(function()
    if not Character or not Humanoid or not HumanoidRootPart or Humanoid.Health <= 0 then
        getCharacter()
        return
    end

    if autoSurvivorEnabled and inMatch() and not isKiller() then
        -- Find killer
        local closestKiller = nil
        local closestDistance = math.huge
        for _, player in pairs(Players:GetPlayers()) do
            if player.Team and player.Team.Name:lower():find("killer") and player.Character and player.Character:FindFirstChild("HumanoidRootPart") then
                local dist = (HumanoidRootPart.Position - player.Character.HumanoidRootPart.Position).Magnitude
                if dist < closestDistance then
                    closestDistance = dist
                    closestKiller = player
                end
            end
        end

        if closestKiller then
            runAwayFromKiller(closestKiller.Character.HumanoidRootPart.Position)
            -- TODO: Add dodgeAbility(), useAbility(), sprint logic here for advanced AI
        else
            -- No killer found, maybe do generator or roam
            autoGenerator()
        end
    elseif autoKillerEnabled and inMatch() and isKiller() then
        -- Killer AI: Find closest survivor and chase
        local closestSurvivor = nil
        local closestDistance = math.huge
        for _, player in pairs(Players:GetPlayers()) do
            if player.Team and player.Team.Name:lower():find("survivor") and player.Character and player.Character:FindFirstChild("HumanoidRootPart") then
                local dist = (HumanoidRootPart.Position - player.Character.HumanoidRootPart.Position).Magnitude
                if dist < closestDistance then
                    closestDistance = dist
                    closestSurvivor = player
                end
            end
        end
        if closestSurvivor then
            Humanoid:MoveTo(closestSurvivor.Character.HumanoidRootPart.Position)
            -- TODO: Use killer abilities with AI here
        else
            Humanoid:MoveTo(HumanoidRootPart.Position) -- idle
        end
    end
end)
